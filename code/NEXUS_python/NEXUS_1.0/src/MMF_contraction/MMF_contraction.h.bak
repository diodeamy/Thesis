
#ifndef MMFCONTRACTION_HEADER
#define MMFCONTRACTION_HEADER


#include <cmath>
#include <algorithm>
#include <vector>
#include <utility>
#include <iostream>
#ifdef ENABLE_OPENMP
#include <omp.h>
#endif

#include <boost/math/special_functions/fpclassify.hpp>

#include <defines.h>
#include <misc.h>
#include <array.h>
#include <vector.h>
#include <matrix.h>
#include <kdtree2.hpp>

using namespace std;



// some overall constants
int grid[] = { 1, 1, 1 };       // the grid dimensions along the three axes
Real length[] = {1., 1., 1.};   // the length of the box along the three dimensions
Real dx[] = {1.,1.,1.};         // the grid spacing along the 3 directions

void setParameters(int nx, int ny, int nz,
                   Real lx, Real ly, Real lz)
{
    grid[0] = nx;
    grid[1] = ny;
    grid[2] = nz;
    length[0] = lx;
    length[1] = ly;
    length[2] = lz;
    for (int i=0; i<NO_DIM; ++i)
        dx[i] = length[i] / grid[i];
}


// returns the total number of valid 'object' cells
int noObjectCells(Array<int,1> &objectSize)
{
    int noCells = 0;
    for (int i=0; i<(int)objectSize.axisSize(0); ++i)
        noCells += objectSize(i);
    return noCells;
}
size_t noObjectCells(Array<int,3> &mask)
{
    size_t noCells = 0;
    Int NX = mask.axisSize(0), NY = mask.axisSize(1), NZ = mask.axisSize(2);
    for (Int i1=0; i1<NX; ++i1)
        for (Int i2=0; i2<NY; ++i2)
            for (Int i3=0; i3<NZ; ++i3)
                if ( mask(i1,i2,i3)>=0 )
                    ++noCells;
                return noCells;
}
size_t noObjectCells(Array<shortInt,3> &mask)
{
    size_t noCells = 0;
    Int NX = mask.axisSize(0), NY = mask.axisSize(1), NZ = mask.axisSize(2);
    for (Int i1=0; i1<NX; ++i1)
        for (Int i2=0; i2<NY; ++i2)
            for (Int i3=0; i3<NZ; ++i3)
                if ( mask(i1,i2,i3)>0 )
                    ++noCells;
                return noCells;
}



// returns the index of a periodic grid
inline int periodicGrid(int index, int nGrid)
{
    if (index>=nGrid) return index-nGrid;
    else if (index<0) return nGrid+index;
    else return index;
}


// function that returns the periodic offsets when translating from periodic to non-periodic boxes
void periodicOffsets(Real offset[][NO_DIM])
{
#if NO_DIM==2
    for (int i1=0; i1<3; ++i1)
        for (int i2=0; i2<3; ++i2)
        {
            offset[i1*3+i2][0] = Real(i1-1) * length[0];
            offset[i1*3+i2][1] = Real(i2-1) * length[1];
        }
#elif NO_DIM==3
    for (int i1=0; i1<3; ++i1)
        for (int i2=0; i2<3; ++i2)
            for (int i3=0; i3<3; ++i3)
            {
                offset[i1*9+i2*3+i3][0] = Real(i1-1) * length[0];
                offset[i1*9+i2*3+i3][1] = Real(i2-1) * length[1];
                offset[i1*9+i2*3+i3][2] = Real(i3-1) * length[2];
            }
#endif
}



int periodicBoundary(Array<Real,2> &iSpinePosition,
                     Real const boundary,
                     vector<Real> &spinePosition,
                     bool const VERBOSE=true)
{
    if (VERBOSE)
        cout << "Extending the periodic box positions to a non-periodic box with boundaries of " << boundary << " Mpc/h ..." << std::flush;
    
    int const noCells = iSpinePosition.axisSize(0);
    int reserveSize =  3*NO_DIM * noCells * int( std::pow(1.+2*boundary/(length[0]+boundary),3) );    //allocate some memory for the particles in the boundary
    spinePosition.reserve( reserveSize );
    for (int i=0; i<noCells; ++i)
        for (int j=0; j<NO_DIM; ++j)
            spinePosition.push_back( iSpinePosition(i,j) );
    
    
    // variables to keep track of the offsets when applying the periodic boundaries
    int const noOffsets = (NO_DIM==2 ? 9:27);
    Real offset[noOffsets][NO_DIM];
    periodicOffsets( offset );

    
    // to speed the search first compute if the particle is inside the inner box => these particles do not have any boundary contributions
    Real innerBox[2*NO_DIM];    //particles inside this box do not have any boundary contributions
    Real outerBox[2*NO_DIM];    //the coordinates of the larger box that includes the boundaries too
    for (int i=0; i<NO_DIM; ++i)
    {
        innerBox[2*i]   = boundary ;
        innerBox[2*i+1] = length[i] - boundary ;
        outerBox[2*i]   = -boundary ;
        outerBox[2*i+1] = length[i] + boundary ;
    }
    int noFinalCells = noCells;     //the final number of cells
    Real pos[NO_DIM], tempPos[NO_DIM];
    for (int i=0; i<noCells; ++i)
    {
        for (int j=0; j<NO_DIM; ++j)
            pos[j] = iSpinePosition(i,j);
        if ( particleInBox(pos,innerBox) )
            continue;
        for (int i1=0; i1<noOffsets; ++i1)
        {
            for (int j=0; j<NO_DIM; ++j)
                tempPos[j] = pos[j] + offset[i1][j];
            if ( not particleInBox(tempPos,outerBox) )
                continue;
            ++noFinalCells;
            for (int j=0; j<NO_DIM; ++j)
                spinePosition.push_back( tempPos[j] );
        }
    }
    
    if (VERBOSE)
        cout << " Done.\n" << "\tAdded " << noFinalCells-noCells << " additional points (" << setprecision(4) << 100.*(noFinalCells-noCells)/noCells << "\%) due to the periodic boundaries.\n";
    return noCells;
}





// returns the cell indices and positions corresponding to valid object grid cells
void validObjectCell(Array<shortInt,3> &mask,
                     Array<int,2> &cellIndices,
                     Array<Real,2> &spinePosition)
{
    int object = 0;
    for (int i1=0; i1<mask.axisSize(0); ++i1)
        for (int i2=0; i2<mask.axisSize(1); ++i2)
            for (int i3=0; i3<mask.axisSize(2); ++i3)
                if ( mask(i1,i2,i3)>0 )
                {
                    cellIndices(object,0) = i1;
                    cellIndices(object,1) = i2;
                    cellIndices(object,2) = i3;
                    spinePosition(object,0) = i1*dx[0];
                    spinePosition(object,1) = i2*dx[1];
                    spinePosition(object,2) = i3*dx[2];
                    ++object;
                }
}





/* Takes a distribution of points and computes the shape of that point distribution. After that it uses the shape to compute the eigenvalues and eigenvectors of the shape.
It takes as input:
        point - the point for which we compute the shape of the cloud of points around it
        positions - a vector with the positions
        radius - the length of the shape
        shapeSize - number of cells for the shape along one direction for the 'radius' distance
        maxExtent - the maximum size associated to a point in the input array
*/
void shapeDirections(Real point[],
                     vector<Real> &positions,
                     Real const radius,
                     int const shapeSize,
                     Real const maxExtent,
                     Real *eigenvalues,
                     Real *eigenvectors)
{
    if ( positions.empty() ) return;
    
    // define an array used to compute the shape of the point cloud
    int const bufferSize = int(maxExtent / radius * shapeSize) + 1;
    int const sSize2 = 2* (shapeSize+bufferSize) + 1;
    bool shapeArray[sSize2][sSize2][sSize2];
    Real const shapeDX = radius / shapeSize;    //width of a shape cell
    Real const shapeDisplacement = shapeDX *  sSize2 / 2.;  //left displacement of the shape array with respect to point position
    
    int const noPoints = positions.size() / NO_DIM;
    Real pointSize = pow( double(radius*radius*radius/noPoints), 1./3. ); //compute the size of a point if they would fill the volume radius^3 uniformly
    if ( pointSize>maxExtent )  // in the case there are only very few points in the neighborhood
        pointSize = maxExtent;
    
    // find the shape of the cloud of points
    for (int i0=0; i0<sSize2; ++i0)
        for (int i1=0; i1<sSize2; ++i1)
            for (int i2=0; i2<sSize2; ++i2)
                shapeArray[i0][i1][i2] = false;
    for (int i=0; i<noPoints; ++i)
    {
        int iStart[NO_DIM], iEnd[NO_DIM];
        for (int j=0; j<NO_DIM; ++j)
        {
            Real pos = positions[i*NO_DIM+j] - point[j] + shapeDisplacement;
            iStart[j] = int( (pos-pointSize) / shapeDX );
            iEnd[j] = int( (pos+pointSize) / shapeDX );
            if ( iStart[j]<0 ) iStart[j] = 0;
            if ( iEnd[j]>=sSize2 ) iEnd[j] = sSize2-1;
        }
        for (int i0=iStart[0]; i0<=iEnd[0]; ++i0)
            for (int i1=iStart[1]; i1<=iEnd[1]; ++i1)
                for (int i2=iStart[2]; i2<=iEnd[2]; ++i2)
                    shapeArray[i0][i1][i2] = true;
    }
    
    
    // compute the reduced momentum of inertia
    Real massCenter[] = {0.,0.,0.};  //the center of the shape
    Real inertiaTensor[] = {0.,0.,0.,0.,0.,0.};//the inertia tensor
    int noShapeCells = 0;
    for (int i0=0; i0<sSize2; ++i0)
        for (int i1=0; i1<sSize2; ++i1)
            for (int i2=0; i2<sSize2; ++i2)
                if ( shapeArray[i0][i1][i2] )
                {
                    massCenter[0] += i0;
                    massCenter[1] += i1;
                    massCenter[2] += i2;
                    ++noShapeCells;
                }
    for (int j=0; j<NO_DIM; ++j)
        massCenter[j] /= noShapeCells;
    for (int i0=0; i0<sSize2; ++i0)
        for (int i1=0; i1<sSize2; ++i1)
            for (int i2=0; i2<sSize2; ++i2)
                if ( shapeArray[i0][i1][i2] )
                {
                    Real tempP[] = { i0-massCenter[0], i1-massCenter[1], i2-massCenter[2] };
                    Real tempD = tempP[0]*tempP[0] + tempP[1]*tempP[1] + tempP[2]*tempP[2];
                    inertiaTensor[0] += tempP[0]*tempP[0] / tempD;
                    inertiaTensor[1] += tempP[0]*tempP[1] / tempD;
                    inertiaTensor[2] += tempP[0]*tempP[2] / tempD;
                    inertiaTensor[3] += tempP[1]*tempP[1] / tempD;
                    inertiaTensor[4] += tempP[1]*tempP[2] / tempD;
                    inertiaTensor[5] += tempP[2]*tempP[2] / tempD;
                }
    
    
    // get the eigenvalues and eigenvectors
    MATRIX::Symmetric<Real,NO_DIM> mat;
    mat.data( inertiaTensor );
    mat.eigenvalues( eigenvalues, eigenvectors, true );
}

// Computes the momentum of inertia for a cloud of points
void cloudDirections(vector<Real> &positions,
                     Real *eigenvalues,
                     Real *eigenvectors)
{
    if ( positions.empty() ) return;
    
    // compute the reduced momentum of inertia
    Real massCenter[] = {0.,0.,0.};  //the center of the shape
    Real inertiaTensor[] = {0.,0.,0.,0.,0.,0.};//the inertia tensor
    int const noPoints = positions.size() / NO_DIM;
    for (int i=0; i<noPoints; ++i)
        for (int j=0; j<NO_DIM; ++j)
            massCenter[j] += positions[i*NO_DIM+j];
    for (int j=0; j<NO_DIM; ++j)
        massCenter[j] /= noPoints;
    for (int i=0; i<noPoints; ++i)
    {
        Real tempP[] = { positions[i*NO_DIM]-massCenter[0], positions[i*NO_DIM+1]-massCenter[1], positions[i*NO_DIM+2]-massCenter[2] };
        Real tempD = tempP[0]*tempP[0] + tempP[1]*tempP[1] + tempP[2]*tempP[2];
        inertiaTensor[0] += tempP[0]*tempP[0] / tempD;
        inertiaTensor[1] += tempP[0]*tempP[1] / tempD;
        inertiaTensor[2] += tempP[0]*tempP[2] / tempD;
        inertiaTensor[3] += tempP[1]*tempP[1] / tempD;
        inertiaTensor[4] += tempP[1]*tempP[2] / tempD;
        inertiaTensor[5] += tempP[2]*tempP[2] / tempD;
    }
    
    
    // get the eigenvalues and eigenvectors
    MATRIX::Symmetric<Real,NO_DIM> mat;
    mat.data( inertiaTensor );
    mat.eigenvalues( eigenvalues, eigenvectors, true );
}


// this function moves an object along a given direction
inline void movePointFromStart(Array<Real,2> &spinePosition,
                               Array<Real,2> &volumeCenter,
                               Array<Real,2> &directionVector,
                               int const object,
                               int const Feature,
                               Real const stepFraction,
                               Array<Real,2> &finalSpinePosition)
{
    Real moveDirection[NO_DIM];
    if (Feature==3)
        distanceAlongPerpendicularDirection( &(spinePosition(object,0)), &(volumeCenter(object,0)), &(directionVector(object,0)), moveDirection );
    else if (Feature==2)
        distanceAlongDirection( &(spinePosition(object,0)), &(volumeCenter(object,0)), &(directionVector(object,0)), moveDirection );
    for (int j=0; j<NO_DIM; ++j)
    {
        finalSpinePosition(object,j) = spinePosition(object,j) + stepFraction * moveDirection[j];
        if ( not boost::math::isfinite(finalSpinePosition(object,j)) )
            finalSpinePosition(object,j) = spinePosition(object,j) + stepFraction * (volumeCenter(object,j) - spinePosition(object,j));
    }
}

// this function moves a point according to a given direction and also checks if the point reached convergence
inline bool movePoint(Array<Real,2> &spinePosition,
                      Array<Real,2> &directionVector,
                      int const object,
                      int const Feature,
                      Real const stepFraction,
                      vector<Real> &neighbors,
                      Real const distanceThreshold,
                      Real const eigenvalueRatioThreshold,
                      Real cosDirectionThreshold)
{
    //compute the center of where the particles are in the given radius
    int const noPoints = neighbors.size() / NO_DIM;
    Real massCenter[] = {0.,0.,0.}; //will keep track of the mass center
    for (int i=0; i<noPoints; ++i)
        for (int j=0; j<NO_DIM; ++j)
            massCenter[j] += neighbors[i*NO_DIM+j];
    for (int j=0; j<NO_DIM; ++j)
        massCenter[j] /= noPoints;
    
    Real moveDirection[NO_DIM], distance = 0.;
    if (Feature==3)
        distance = distanceAlongPerpendicularDirection( &(spinePosition(object,0)), massCenter, &(directionVector(object,0)), moveDirection );
    else if (Feature==2)
        distance = distanceAlongDirection( &(spinePosition(object,0)), massCenter, &(directionVector(object,0)), moveDirection );
    for (int j=0; j<NO_DIM; ++j)
        if ( boost::math::isfinite(moveDirection[j]) )
            spinePosition(object,j) += stepFraction * moveDirection[j];
    
    if (distance<distanceThreshold) // check if the point converged to its final position
    {
        Real eigenvalues[NO_DIM], eigenvectors[NO_DIM*NO_DIM];
        cloudDirections( neighbors, eigenvalues, eigenvectors);
        Real eigenvalueRatio = Feature==3 ? eigenvalues[1]/eigenvalues[2] : eigenvalues[0]/eigenvalues[1];
        int offset = Feature==3 ? 6 : 0;
        Real cosDirection = fabs( scalarProduct( moveDirection, &(eigenvectors[offset]) ) );
        if ( cosDirection>cosDirectionThreshold and eigenvalueRatio<eigenvalueRatioThreshold )
            return true;
    }
    return false;
}
inline bool movePoint(Array<Real,2> &spinePosition,
                      int const object,
                      int const Feature,
                      Real const stepFraction,
                      vector<Real> &neighbors,
                      Real const distanceThreshold,
                      Real const eigenvalueRatioThreshold)
{
    //compute the center of where the particles are in the given radius
    int const noPoints = neighbors.size() / NO_DIM;
    Real massCenter[] = {0.,0.,0.}; //will keep track of the mass center
    for (int i=0; i<noPoints; ++i)
        for (int j=0; j<NO_DIM; ++j)
            massCenter[j] += neighbors[i*NO_DIM+j];
    for (int j=0; j<NO_DIM; ++j)
        massCenter[j] /= noPoints;
    
    Real moveDirection[NO_DIM];
    for (int j=0; j<NO_DIM; ++j)
        moveDirection[j] = massCenter[j] - spinePosition(object,j);
    Real distance = magnitude( moveDirection );
    for (int j=0; j<NO_DIM; ++j)
        if ( boost::math::isfinite(moveDirection[j]) )
            spinePosition(object,j) += stepFraction * moveDirection[j];
    
    if (distance<distanceThreshold) // check if the point converged to its final position
    {
        Real eigenvalues[NO_DIM], eigenvectors[NO_DIM*NO_DIM];
        cloudDirections( neighbors, eigenvalues, eigenvectors);
        Real eigenvalueRatio = Feature==3 ? eigenvalues[1]/eigenvalues[2] : eigenvalues[0]/eigenvalues[1];
        if ( eigenvalueRatio<eigenvalueRatioThreshold )
            return true;
    }
    return false;
}


/* This function computes the inertia tensor of the cloud of points around a given point. Returns the numbers of cells that changed direction more than a given angle. It takes the following arguments:
 *              spinePosition   = the input point positions
 *              oldDirections   = the input onld directions associated to the points
 *              validDirections = true/false if the points already converged or not (if points already converged, it skips them)
 *              Feature         = 3=filament, 2=wall
 *              radius          = the radius around which to search for the cloud points
 *              directions      = array to keep track of the output directions
 *              cosTolerance    = minimum cosinus of the angle when the old and new direction when we consider that convergence is achieved ( 0.996 = cos(5 degrees) )
 */
int directionDetection(Array<Real,2> &spinePosition,
                       Array<Real,2> &oldDirections,
                       Array<bool,1> &validDirections,
                       int const Feature,
                       Real const radius,
                       Array<Real,2> &directions,
                       Real const cosTolerance = 0.996)
{
//    cout << "Finding the feature direction for each valid object voxel.\n\tDone: ";
    ProgressMessage message;
    message.updateProgress( 0 );
    int const minimumNoNeigbors = 10;   // the code searches for the neighbor within a given radius - if iot find less than these number of neigbhors, it searches for these nearest neighbors
    
    
    // take into account the periodic boundaries => copy the particles on the edge
    vector<Real> tempSpinePosition;
    int const noBaseCells = spinePosition.axisSize(0);
    int const noTotalCells = periodicBoundary( spinePosition, radius, tempSpinePosition, false );
    
    // copy the positions in a boost matrix and feed it to the kd-tree algorithm
    kdtree2_array positions(extents[noTotalCells][NO_DIM]);
    for (int i=0; i<noTotalCells; ++i)
        for (int j=0; j<NO_DIM; ++j)
            positions[i][j] = tempSpinePosition[i*NO_DIM+j];
    
    // construct the tree that searches for the closest points
    kdtree2* tree;
    tree = new kdtree2( positions, false );
    tree->sort_results = true;
    kdtree2_result_vector result;   //stores the result of the tree search
    
    
    // loop over all the cells
    Real R2 = radius*radius;
    vector<Real> neighbors;
    int noDifferentDirections = 0;
#ifdef ENABLE_OPENMP
    int const numThreads = omp_get_max_threads();
    #pragma omp parallel for private(result,neighbors) reduction(+ :noDifferentDirections)
#endif
    for (int object=0; object<noBaseCells; ++object)
    {
        if ( validDirections(object) )
        {
            for (int j=0; j<NO_DIM; ++j)
                directions(object,j) = oldDirections(object,j);
            continue;
        }
        tree->r_nearest_around_point( object, 0, R2, result );
        if ( result.empty() or int(result.size())<minimumNoNeigbors )
            tree->n_nearest_around_point( object, 0, minimumNoNeigbors, result );
        
        // copy the positions of the points in the point cloud to a vector array
        neighbors.clear();
        for (size_t i=0; i<result.size(); ++i)
            for (int j=0; j<NO_DIM; ++j)
                neighbors.push_back( tempSpinePosition[result[i].idx*NO_DIM+j] );
        
        // compute the eigenvalues and eigenvectors for the given point cloud
        Real eigenvalues[NO_DIM], eigenvectors[NO_DIM*NO_DIM];
        cloudDirections( neighbors, eigenvalues, eigenvectors );
        
        int offset = Feature==3 ? 6 : 0;
        Real factor = eigenvectors[offset]>0. ? 1. : -1.;   //choose the same direction for all eigenvectors
        Real tempM = magnitude( &(eigenvectors[offset]) ); //magnitude
        for (int j=0; j<NO_DIM; ++j)
            directions(object,j) = factor/tempM * eigenvectors[offset+j];
        if ( tempM<1.e-5 or not boost::math::isfinite(tempM) )  //keep track if no eigenvector is set
            for (int j=0; j<NO_DIM; ++j)
                directions(object,j) = 1./sqrt(3.); //set some random direction
        
        // compare the new direction with the old one
        if ( fabs( scalarProduct(&(oldDirections(object,0)),&(eigenvectors[offset])) )>cosTolerance )
            validDirections(object) = true;
        else
            ++noDifferentDirections;
        
#ifdef ENABLE_OPENMP
        if (omp_get_thread_num()==0) message.updateProgress( 100*numThreads*object/noBaseCells );
#else
        message.updateProgress( 100*object/noBaseCells );
#endif
    }
    cout << "100\%";
    cout << "   Not converged: " << noDifferentDirections << " - " << std::setprecision(3) << 100.*noDifferentDirections/noBaseCells << "\%.\n";
    return noDifferentDirections;
}






/* Contracts the filaments/walls to their spine/principal wall. It takes the following arguments:
 *          spinePosition   = the initial position of each voxel that is part of the filament/wall - on exit will return the contracted spine/wall position for that point
 *          directionVector = the direction of the filament / normal to the wall for each of the above points
 *          feature         = 3 for filaments and 2 for walls
 *          radius          = the radius around which to look for neighbors - it is the smoothing radius along which we contract the object
 * 
 * the following are parameters that influence when to stop the iteration:
 *          convergeFraction       = stop when less than this fraction of points did not converge (or if maxLoop was reached)
 *          distanceThreshold      = consider a point converged if it moved less than this distance in this iteration steps
 *          eigenvalueThreshold    = consider a point converged if it the shape of the point cloud around it is very anisotropic (i.e. lambda_2/lambda_3 < eigenvalueThreshold for filaments and lambda_1/lambda_2 < eigenvalueThreshold for walls - we have lambda_1 <= lambda_2 <= lambda_3 and the fila direction is given by eigenvector_3 while the wall normal is given by eigenvector_1 )
 *          cosDirectionThreshold  = consider a point converged if the abs. of the scalar poduct is larger than this value
 *          maxLoop                = stop after this many loops indifferently if convergence was achieved
 * NOTE: For a point to be considered converged it needs to satisfy all 3 threshold criteria: distanceThreshold, eigenvalueThreshold and cosDirectionThreshold.
 *  */
void MMFContraction(Array<Real,2> &spinePosition,
                    Array<Real,2> &directionVector,
                    int feature,
                    Real const radius,
                    Real const convergeFraction = 0.1,
                    Real const distanceThreshold = 0.01,
                    Real const eigenvalueThreshold = 0.1,
                    Real const cosDirectionThreshold = 0.5,
                    int const maxLoop = 60)
{
    cout << "Contracting the Cosmic Web objects to a spine for filaments and plane for walls:\n" << flush;
    int const noBaseCells = spinePosition.axisSize(0);
    
    
    // the loop that contracts the structures
    Real const stepFraction = .99;          //what fraction of the distance to move every step
    Array<bool,1> convergedPoints(noBaseCells);
    convergedPoints = false;
    bool continueLoop = true;
    int loopNo = 0;
    while (continueLoop and loopNo<maxLoop)
    {
        // take into account the periodic boundaries => copy the particles on the edge
        vector<Real> tempSpinePosition;
        int const noTotalCells = periodicBoundary( spinePosition, radius, tempSpinePosition, false );
        
        // copy the positions in a boost matrix and feed it to the kd-tree algorithm
        kdtree2_array positions(extents[noTotalCells][NO_DIM]);
        for (int i=0; i<noTotalCells; ++i)
            for (int j=0; j<NO_DIM; ++j)
                positions[i][j] = tempSpinePosition[i*NO_DIM+j];
        
        // construct the tree that searches for the closest points
        kdtree2* tree;
        tree = new kdtree2( positions, false );
        tree->sort_results = true;
        kdtree2_result_vector result;   //stores the result of the tree search
        
        // search all the neighbors within 'radius' and move the point accordingly
        Real R2 = radius*radius;
        int noNotConverged = 0;
        vector<Real> neighbors;
#ifdef ENABLE_OPENMP
        #pragma omp parallel for private(result,neighbors) reduction(or :continueLoop) reduction(+ :noNotConverged)
#endif
        for (int object=0; object<noBaseCells; ++object)
        {
            if ( convergedPoints(object) ) continue;
            
            tree->r_nearest_around_point( object, 0, R2, result );
            if ( result.empty() ) continue;
            
            // move the point along the given direction
            neighbors.clear();
            for (size_t i=0; i<result.size(); ++i)
                for (int j=0; j<NO_DIM; ++j)
                    neighbors.push_back( positions[result[i].idx][j] );
            
            convergedPoints(object) = movePoint( spinePosition, directionVector, object, feature, stepFraction, neighbors, distanceThreshold, eigenvalueThreshold, cosDirectionThreshold );
            if ( not convergedPoints(object) )
                ++noNotConverged;
            
        }
        if ( 1.*noNotConverged/noBaseCells<convergeFraction )
            continueLoop = false;
        
        cout << "<<<<< Iteration " << loopNo << " / " << maxLoop << ": Fraction not converged: "  << std::setprecision(3) << noNotConverged*100./noBaseCells << "\%\n";
        ++loopNo;
    }
    cout << "\tDid " << loopNo << " iterations out of a maximum of " << maxLoop << ".\n";
}
/* Does the same as the above function, but does not use a direction along which to move, it moves along the CM direction */
void MMFContraction(Array<Real,2> &spinePosition,
                    int feature,
                    Real const radius,
                    Real const convergeFraction = 0.1,
                    Real const distanceThreshold = 0.01,
                    Real const eigenvalueThreshold = 0.1,
                    int const maxLoop = 60)
{
    cout << "Contracting the Cosmic Web objects:\n" << flush;
    int const noBaseCells = spinePosition.axisSize(0);
    ProgressMessage message;
    
    
    // the loop that contracts the structures
    Real const stepFraction = .99;          //what fraction of the distance to move every step
    Array<bool,1> convergedPoints(noBaseCells);
    convergedPoints = false;
    bool continueLoop = true;
    int loopNo = 0;
    while (continueLoop and loopNo<maxLoop)
    {
        cout << "<<<<< Iteration " << loopNo << " / " << maxLoop << " ---   Done : " ;
        message.updateProgress(0);
        
        // take into account the periodic boundaries => copy the particles on the edge
        vector<Real> tempSpinePosition;
        int const noTotalCells = periodicBoundary( spinePosition, radius, tempSpinePosition, false );
        
        // copy the positions in a boost matrix and feed it to the kd-tree algorithm
        kdtree2_array positions(extents[noTotalCells][NO_DIM]);
        for (int i=0; i<noTotalCells; ++i)
        {
            for (int j=0; j<NO_DIM; ++j)
                positions[i][j] = tempSpinePosition[i*NO_DIM+j];
            if ( magnitude(&(tempSpinePosition[i*NO_DIM])) > Real(202.1) )
                cout << i << " of " << noBaseCells << "\n";
            }
        
        // construct the tree that searches for the closest points
        kdtree2* tree;
        tree = new kdtree2( positions, false );
        tree->sort_results = true;
        kdtree2_result_vector result;   //stores the result of the tree search
        
        
        // search all the neighbors within 'radius' and move the point accordingly
        Real R2 = radius*radius;
        int noNotConverged = 0;
        vector<Real> neighbors;
#ifdef ENABLE_OPENMP
        #pragma omp parallel for private(result,neighbors) reduction(or :continueLoop) reduction(+ :noNotConverged)
#endif
        for (int object=0; object<noBaseCells; ++object)
        {
            if ( convergedPoints(object) ) continue;
            
            tree->r_nearest_around_point( object, 0, R2, result );
            if ( result.empty() ) continue;
            
            // move the point along the given direction
            neighbors.clear();
            for (size_t i=0; i<result.size(); ++i)
                for (int j=0; j<NO_DIM; ++j)
                    neighbors.push_back( positions[result[i].idx][j] );
            
            convergedPoints(object) = movePoint( spinePosition, object, feature, stepFraction, neighbors, distanceThreshold, eigenvalueThreshold );
            if ( not convergedPoints(object) )
                ++noNotConverged;
            
            if (omp_get_thread_num()==0) message.updateProgress( 100*object/noBaseCells );
        }
        if ( 1.*noNotConverged/noBaseCells<convergeFraction )
            continueLoop = false;
        
        cout << "100%   Fraction not converged: "  << std::setprecision(3) << noNotConverged*100./noBaseCells << "\%\n";
        ++loopNo;
    }
    cout << "\tDid " << loopNo << " iterations out of a maximum of " << maxLoop << ".\n";
}


/* Uses an iterative method to get the direction of the filament/wall.
It finds the characteristic neighborhood of the point and than it moves it to the center of that volume following the point density gradient. Once it does so for all the points, computes the characteristic direction of the resulting point set. It repeats the contraction from the initial direction, but now following the direction of the feature it is in.*/
void MMFObjectDirection(Array<shortInt,3> &mask,
                        int const Feature,
                        Real const radius,
                        Array<int,2> &cellIndices,
                        Array<Real,2> &spinePosition,
                        Array<Real,2> &directionVector)
{
    cout << "Contracting the MMF objects to a spine for filaments and plane for walls ...\n" << flush;
    ProgressMessage message;
    
    // get the cells which are part of the filament/wall
    validObjectCell( mask, cellIndices, spinePosition );
    int const noBaseCells = spinePosition.axisSize(0);
    
    
    // loop over all the structures and find their corresponding volume and number of neighbors
    cout << "\tComputing the specific size at each point.\n\tDone:  " << flush;
    message.updateProgress( 0 );
    
    // take into account the periodic boundaries => copy the particles on the edge
    vector<Real> tempSpinePosition(2,NO_DIM);
    int const noTotalCells = periodicBoundary( spinePosition, radius, tempSpinePosition, false );
    
    // copy the positions in a boost matrix and feed it to the kd-tree algorithm
    kdtree2_array positions(extents[noTotalCells][NO_DIM]);
    for (int i=0; i<noTotalCells; ++i)
        for (int j=0; j<NO_DIM; ++j)
            positions[i][j] = tempSpinePosition[i*NO_DIM+j];
    
    // construct the tree that searches for the closest points
    kdtree2* tree;
    tree = new kdtree2( positions, false );
    tree->sort_results = true;
    kdtree2_result_vector result;   //stores the result of the tree search
    
    // the loop over the cells in the object
    Real const stepFraction = .99;            //what fraction of the distance to move every step
    Real skyCoverage = 0.1;
    int maxIterations = int( (5.-radius) / dx[0] );    //do not search beyond this radius
    // allocate arrays for the volume center of each point and the direction associated to it
    Array<Real,2> spinePosition2(noBaseCells,NO_DIM);
    Array<Real,2> volumeCenter(noBaseCells,NO_DIM);
#ifdef ENABLE_OPENMP
    int const numThreads = omp_get_max_threads();
    #pragma omp parallel for private(result)
#endif
    for (int object=0; object<noBaseCells; ++object)
    {
        int size1 = 0;
        for (int j1=0; j1<=maxIterations; ++j1)
        {
            Real tempR2 = (radius+j1*dx[0]) * (radius+j1*dx[0]);
            tree->r_nearest_around_point( object, 0, tempR2, result );
            Real numberThreshold = skyCoverage * 4*3.14*tempR2 / (dx[1]*dx[2]);
            
            if ( (result.size()-size1)<numberThreshold )
                break;
            size1 = result.size();
        }
        
        // get the volume center
        Real particleCenter[] = {0.,0.,0.}; //will keep track of the particle center
        for (size_t i=0; i<result.size(); ++i)
            for (int j=0; j<NO_DIM; ++j)
                particleCenter[j] += positions[result[i].idx][j];
        for (int j=0; j<NO_DIM; ++j)
            volumeCenter(object,j) = particleCenter[j] / result.size();
        
        // get the displacement to the particle center and move the particle to that position
        for (int j=0; j<NO_DIM; ++j)
            spinePosition2(object,j) = spinePosition(object,j) + stepFraction * (volumeCenter(object,j) - spinePosition(object,j));
        
#ifdef ENABLE_OPENMP
        if (omp_get_thread_num()==0) message.updateProgress( 100*object*numThreads/noBaseCells );
#else
        message.updateProgress( 100*object/noBaseCells );
#endif
    }
    cout << "100\%\n";
    
    
    // compute the eigenvectors
    directionVector.assign( 0. );
    Array<Real,2> tempDirections(noBaseCells,NO_DIM);
    Array<bool,1> validDirections(noBaseCells);
    validDirections.assign( false );
    directionDetection( spinePosition2, tempDirections, validDirections, Feature, radius, directionVector );


    // the loop that iterativelly finds the direction of the filament at each point
    cout << "\tIterating until the all points have a valid converged direction ...\n" << flush;
    int loopNo = 0, maxLoop = 40;
    Real const convergeThreshold = 0.05;     // stop when this fraction of the points have a converged direction
    Real const accelerationThreshold = 0.1;  //start the acceleration process when less than this fraction of the points does not have a valid direction
    bool useAcceleration = false;
    bool stopLoop = false;
    while (not stopLoop and loopNo<maxLoop)
    {
        cout << "<<<< Iteration " << loopNo << " / " << maxLoop-1 << ": Done: ";
        
        // compute the new positions of the particles using the updated direction information
        for (int object=0; object<noBaseCells; ++object)
        {
            if ( validDirections(object) ) continue;
            
            if (useAcceleration and loopNo%10==0)
            {
                tree->n_nearest_around_point( object, 0, 100, result );
                for (size_t i=0; i<result.size(); ++i)
                    if ( result[i].idx<noBaseCells )
                        if ( validDirections(result[i].idx) )
                        {
                            for (int j=0; j<NO_DIM; ++j)    //copy the new center information and the direction of the neighbor
                            {
                                volumeCenter(object,j) = volumeCenter(result[i].idx,j);
                                directionVector(object,j) = directionVector(result[i].idx,j);
                            }
                            break;
                        }
            }
            
            movePointFromStart( spinePosition, volumeCenter, directionVector, object, Feature, stepFraction, spinePosition2 );
        }
        
        // update the directions by computing the shape eigenvectors
        int notConverged = directionDetection( spinePosition2, directionVector, validDirections, Feature, radius, tempDirections );
        Real fractionNotConverged = (1.*notConverged)/noBaseCells;
        if (fractionNotConverged<convergeThreshold)
            stopLoop = true;
        else if (fractionNotConverged<accelerationThreshold)
            useAcceleration = true;
        directionVector = tempDirections;
        
        ++loopNo;
    }
    
    spinePosition2.assign( spinePosition );
    MMFContraction( spinePosition2, directionVector, Feature, radius, 0.1 );
    validDirections.assign( false );
    directionDetection( spinePosition2, directionVector, validDirections, Feature, radius, tempDirections );
    directionVector.assign( tempDirections );
    
    
    cout << "Did " << loopNo << " iterations out of a maximum of " << maxLoop << ".\n";
}
/* This function detects the geometrical direction of filaments and walls.
 * 
 * 
 */
void MMFObjectDirection(Array<shortInt,3> &mask,
                        int const Feature,
                        Real const radius,
                        Array<int,2> &cellIndices,
                        Array<Real,2> &spinePosition,
                        Array<Real,2> &directionVector,
                        Real const convergeFraction = 0.1,
                        Real const distanceThreshold = 0.01,
                        Real const eigenvalueThreshold = 0.1,
                        int const maxLoop = 60,
                        int const maxIteration = 10)
{
    cout << "Contracting the MMF objects to a spine for filaments and plane for walls ...\n" << flush;
    
    // get the cells which are part of the filament/wall
    validObjectCell( mask, cellIndices, spinePosition );
    int const noBaseCells = spinePosition.axisSize(0);
    cout << "Done 1\n" << flush;
    
    
    // first contract the points along the volume center direction
    cout << "\tContracting the objects using the volume center in the imediate neighborhood:\n" << flush;
    Array<Real,2> initialSpinePosition(noBaseCells,NO_DIM);
    initialSpinePosition = spinePosition;
    MMFContraction( spinePosition, Feature, radius, convergeFraction, distanceThreshold, eigenvalueThreshold, maxLoop );
    cout << "Done 2\n" << flush;
    // compute the eigenvector of the cloud points and the direction associated to them
    Array<Real,2> tempDirections(noBaseCells,NO_DIM);
    Array<bool,1> validDirections(noBaseCells);
    tempDirections.assign( Real(0.) );
    validDirections.assign( false );
    directionDetection( spinePosition, tempDirections, validDirections, Feature, radius, directionVector );
    cout << "Done 3\n" << flush;
    
    
    // now iterate until reaching convergence in the filament/wall direction 
    cout << "\tIteration computation until achieving convergence :" << flush;
    for (int i=0; i<maxIteration; ++i)
    {
        spinePosition = initialSpinePosition;
        tempDirections = directionVector;
        
        MMFContraction( spinePosition, directionVector, Feature, radius, convergeFraction, distanceThreshold, eigenvalueThreshold, 0.5, maxLoop );
        
        size_t const notConverged = directionDetection( spinePosition, tempDirections, validDirections, Feature, radius, directionVector );
        if ( (1.*notConverged)/noBaseCells<0.1 )
            break;
    }
//    cout << "Did " << loopNo << " iterations out of a maximum of " << maxLoop << ".\n";
}



#endif
