
#include <string>
#include <fstream>
#include <cmath>

#include <defines.h>
#include <array.h>
#include <miscellaneous.h>
#include <linear_fit.h>
#include <arrayProperties.h>
#include <MMF_computations.h>
using namespace std;

namespace LSM = LEAST_SQUARE_METHOD;
typedef LSM::FitPowerLawFunction<Real>                       powerLaw;
typedef LSM::FitLinearFunction<Real>                         linear;
typedef LSM::FitParabolaFunction<Real>                       parabola;
typedef LSM::FitLogNormalFunction<Real>                      logNormal;
typedef LSM::FitMultipleFunctions<Real,powerLaw,powerLaw>    twoPowerLaw;



/* Fits the blob response function with two power laws and finds the intersection point of the two functions. It prints the data and the fit details to an ASCII file. */
void outputNodeThreshold(Array<Real,3> &density,
                         Array<Real,3> &response,
                         int const neighborType,
                         Real const virialDensity,
                         Real const minimumSize,
                         Array<Real,1> &threshold,
                         string outputFilename,
                         string const programOptions)
{
    // Find the fraction of virial objects for a given threshold value
    size_t const noThresholds = threshold.size();
    cout << "\n\nComputing the optimal threshold for nodes using " << noThresholds << " thresholds values, with 'virial density' = " << virialDensity << " and 'minSize' = " << minimumSize << " in units of average mass in voxel:\n" << flush;
    cout << "  threshold index    threshold value     valid nodes(\%)\n";
    Array<Real,1> thresholdResponse( noThresholds );
    for (size_t i=0; i<noThresholds; ++i)
    {
        cout << "   " << setw(4) << i+1 << " / " << noThresholds << "\t\t" << setprecision(2) << setw(4) << threshold[i] << "\t\t" << flush;
        thresholdResponse[i] = fractionVirialBlobs( density, response, threshold[i], neighborType, virialDensity, minimumSize );
        cout << setprecision(2) << setw(4) << thresholdResponse[i]*100. << "\n";
    }
    
    
     // compute the optimal threshold
    Array<Real,1> tempFraction(noThresholds);
    for (size_t i=0; i<noThresholds; ++i) tempFraction[i] = thresholdResponse[i];
    int position = -1;
    Real optimalFraction = Real(0.8);
    for (size_t i=0; i<noThresholds-1; ++i)
        if ( tempFraction[i]<=optimalFraction and tempFraction[i+1]>optimalFraction )
        {
            position = i;
            break;
        }
    Real optimalThreshold = Real(0.);
    if ( position!=-1 ) // approximate as linear the tempFraction function between the two thresholds below and above 'optimalFraction'
    {
        Real slope = (tempFraction[position] - tempFraction[position-1]) / (threshold[position] - threshold[position-1]);
        Real constant = tempFraction[position] - slope * threshold[position];
        optimalThreshold = (optimalFraction - constant) / slope;
        cout << "\nOptimal threshold value: " << setprecision(4) << optimalThreshold << "\n";
    }
    else cout << "# Optimal threshold value: None\n";
    
    
    
    // open the output file and write the data
    cout << "Writting the results to the ASCII file '" << outputFilename << "' ... " << flush;
    fstream outputFile;
    openOutputTextFile( outputFile, outputFilename );   //open the output file
    BOOST_ASSERT( noParameters==4 );
    
    if ( position!=-1 )
        outputFile << "# Optimal threshold value: " << optimalThreshold << "\n";
    else outputFile << "# Optimal threshold value: None\n";
    outputFile << "# The file contains the results of finding the optimal threshold for node detection with MMF. The 1st column gives the threshold values while the second gives the fraction of nodes which have an average density above the virial density.\n"
            << "# The results were obtained using the command:  " << programOptions << "\n\n";
    
    for (size_t i=0; i<noThresholds; ++i)
        outputFile << threshold[i] << "\t" << thresholdResponse[i] << "\n";
    outputFile.close();
    cout << "Done.\n";
}



/* Fits the filament response function with a quadratic function around the maximum value of 'thresholdResponseFunction'. It prints the data and the fit details to an ASCII file. */
void outputFilamentThreshold(Array<Real,3> &response,
                             int const neighborType,
                             Real const minimumSize,
                             Array<Real,1> &threshold,
                             string outputFilename,
                             string const programOptions)
{
    // Find the optimal filament threshold
    size_t const noThresholds = threshold.size();
    size_t gridSize = response.size();
    cout << "\n\nComputing the optimal threshold for filaments using " << noThresholds << " thresholds values and 'minimum object size' = " << minimumSize << ":\n" << flush;
    cout << "  threshold index   threshold value   largest filament(\%)\n";
    Array<Real,1> largestObjectVolumeFraction(noThresholds), // largest object volume fraction compared to large objects
            volumeFill(noThresholds);                        // volume fill of all objects
    Array<size_t,1> largestObjectVolume(noThresholds),       // largest object volume
            noLargeObjects(noThresholds);                    // number large objects above 'minimumSize'
    
    for (size_t i=0; i<noThresholds; ++i)
    {
        cout << "   " << setw(4) << i+1 << " / " << noThresholds << "\t\t  " << setprecision(2) << setw(4) << threshold[i] << "\t\t" << flush;
        largestObjectVolumeFraction[i] = countObjects( response, threshold[i], neighborType, minimumSize, &(largestObjectVolume[i]), &(noLargeObjects[i]), &(volumeFill[i]) );
        cout << setprecision(2) << setw(4) << largestObjectVolume[i]/(volumeFill[i]*gridSize)*100. << "\n";
    }
    
    
    // compute the optimal threshold
    Array<Real,1> tempFraction(noThresholds);
    for (size_t i=0; i<noThresholds; ++i) tempFraction[i] = largestObjectVolume[i]/(volumeFill[i]*gridSize);
    int position = -1;
    Real percolationFraction = Real(0.5);
    for (size_t i=noThresholds-1; i>0; --i)
        if ( tempFraction[i]<=percolationFraction and tempFraction[i-1]>percolationFraction )
        {
            position = i;
            break;
        }
    Real optimalThreshold = Real(0.);
    if ( position!=-1 ) // approximate as linear the tempFraction function between the two thresholds below and above 'percolationFraction'
    {
        Real slope = (tempFraction[position] - tempFraction[position-1]) / (threshold[position] - threshold[position-1]);
        Real constant = tempFraction[position] - slope * threshold[position];
        optimalThreshold = (percolationFraction - constant) / slope;
        cout << "\nOptimal threshold value: " << setprecision(4) << optimalThreshold << "\n";
    }
    else cout << "# Optimal threshold value: None\n";
    
    
    
    ArrayProperties<size_t,size_t> prop( noLargeObjects.ptrData(), noLargeObjects.size() );
    Real maxNoLargeObjects = Real(prop.valueMaximum());
    
    
    // open the output file and write the data
    cout << "Writting the results to the ASCII file '" << outputFilename << "' ... " << flush;
    fstream outputFile;
    openOutputTextFile( outputFile, outputFilename );   //open the output file
    BOOST_ASSERT( noParameters==3 );
    
    if ( position!=-1 )
        outputFile << "# Optimal threshold value: " << optimalThreshold << "\n";
    else outputFile << "# Optimal threshold value: None\n";
    outputFile << "# The file contains the results of finding the optimal threshold for filament detection with MMF.The columns give the following information:\n"
            << "#\t 1st = threshold values\n"
            << "#\t 2nd = ratio of the volume of the largest object to the volume in all objects\n"
            << "#\t 3rd = ratio of the volume of the largest object to the volume in large objects\n"
            << "#\t 4th = the normalized number of large objects for the given threshold\n"
            << "#\t 5th = the volume fraction filled by all objects for the given threshold\n"
            << "#\t 6th = the absolute size of the largest object\n"
            << "#\t 7th = the absolute numbers for column 4\n"
            << "# The results were obtained using the command:  " << programOptions << "\n\n";
    
    for (size_t i=0; i<noThresholds; ++i)
        outputFile << threshold[i] << "\t" << largestObjectVolume[i]/(volumeFill[i]*gridSize) << "\t" << largestObjectVolumeFraction[i] << "\t" << noLargeObjects[i]/maxNoLargeObjects << "\t" << volumeFill[i] << "\t" << largestObjectVolume[i] << "\t" << noLargeObjects[i] << "\n";
    outputFile.close();
    cout << "Done.\n";
}



/* Fits the wall response function with a quadratic function around the maximum value of 'thresholdResponseFunction'. It prints the data and the fit details to an ASCII file. */
void outputWallThreshold(Array<Real,3> &response,
                         int const neighborType,
                         Real const minimumSize,
                         Array<Real,1> &threshold,
                         string outputFilename,
                         string const programOptions)
{
    // Find the optimal wall threshold
    size_t const noThresholds = threshold.size();
    size_t gridSize = response.size();
    cout << "\n\nComputing the optimal threshold for walls using " << noThresholds << " thresholds values and 'minimum object size' = " << minimumSize << ":\n" << flush;
    cout << "  threshold index   threshold value   largest wall(\%)\n";
    Array<Real,1> largestObjectVolumeFraction(noThresholds), // largest object volume fraction compared to large objects
            volumeFill(noThresholds);                        // volume fill of all objects
    Array<size_t,1> largestObjectVolume(noThresholds),       // largest object volume
            noLargeObjects(noThresholds);                    // number large objects above 'minimumSize'
    
    for (size_t i=0; i<noThresholds; ++i)
    {
        cout << "   " << setw(4) << i+1 << " / " << noThresholds << "\t\t  " << setprecision(2) << setw(4) << threshold[i] << "\t\t" << flush;
        largestObjectVolumeFraction[i] = countObjects( response, threshold[i], neighborType, minimumSize, &(largestObjectVolume[i]), &(noLargeObjects[i]), &(volumeFill[i]) );
        cout << setprecision(2) << setw(4) << largestObjectVolume[i]/(volumeFill[i]*gridSize)*100. << "\n";
    }
    
    
    // compute the optimal threshold
    Array<Real,1> tempFraction(noThresholds);
    for (size_t i=0; i<noThresholds; ++i) tempFraction[i] = largestObjectVolume[i]/(volumeFill[i]*gridSize);
    int position = -1;
    Real percolationFraction = Real(0.5);
    for (size_t i=noThresholds-1; i>0; --i)
        if ( tempFraction[i]<=percolationFraction and tempFraction[i-1]>percolationFraction )
    {
        position = i;
        break;
    }
    Real optimalThreshold = Real(0.);
    if ( position!=-1 ) // approximate as linear the tempFraction function between the two thresholds below and above 'percolationFraction'
    {
        Real slope = (tempFraction[position] - tempFraction[position-1]) / (threshold[position] - threshold[position-1]);
        Real constant = tempFraction[position] - slope * threshold[position];
        optimalThreshold = (percolationFraction - constant) / slope;
        cout << "\nOptimal threshold value: " << optimalThreshold << "\n";
    }
    else cout << "# Optimal threshold value: None\n";
    
    
    
    ArrayProperties<size_t,size_t> prop( noLargeObjects.ptrData(), noLargeObjects.size() );
    Real maxNoLargeObjects = Real(prop.valueMaximum());
    
    
    // open the output file and write the data
    cout << "Done.\nWritting the results to the ASCII file '" << outputFilename << "' ... " << flush;
    fstream outputFile;
    openOutputTextFile( outputFile, outputFilename );   //open the output file
    BOOST_ASSERT( noParameters==3 );
    
    if ( position!=-1 )
        outputFile << "# Optimal threshold value: " << optimalThreshold << "\n";
    else outputFile << "# Optimal threshold value: None\n";
    outputFile << "# The file contains the results of finding the optimal threshold for wall detection with MMF.The columns give the following information:\n"
            << "#\t 1st = threshold values\n"
            << "#\t 2nd = ratio of the volume of the largest object to the volume in all objects\n"
            << "#\t 3rd = ratio of the volume of the largest object to the volume in large objects\n"
            << "#\t 4th = the normalized number of large objects for the given threshold\n"
            << "#\t 5th = the volume fraction filled by all objects for the given threshold\n"
            << "#\t 6th = the absolute size of the largest object\n"
            << "#\t 7th = the absolute numbers for column 4\n"
            << "# The results were obtained using the command:  " << programOptions << "\n\n";
    
    for (size_t i=0; i<noThresholds; ++i)
        outputFile << threshold[i] << "\t" << largestObjectVolume[i]/(volumeFill[i]*gridSize) << "\t" << largestObjectVolumeFraction[i] << "\t" << noLargeObjects[i]/maxNoLargeObjects << "\t" << volumeFill[i] << "\t" << largestObjectVolume[i] << "\t" << noLargeObjects[i] << "\n";
    outputFile.close();
    cout << "Done.\n";
}


/* This function computes the histogram for a array and outputs the results to an ASCII file. */
void outputResponseHessian(Real *ptr,
                           Int const size,
                           Real const *histogramProperties,
                           string outputFilename,
                           string const programOptions)
{
    // first compute the histogram
    cout << "Computing the histogram of the response data using " << int(histogramProperties[2]) << " logarithmic bins in the interval " << histogramProperties[0] << " to " << histogramProperties[1] << " of the maximum response value:\n";
    ArrayProperties<Real,Int> prop( ptr, size );
    Real maximum = prop.valueMaximum();       // get the maximum response
    Int const histogramBins = Int( histogramProperties[2] );
    cout << "\t maximum response: " << maximum << "\n" << flush;
    prop.histogram( histogramProperties[0]*maximum, histogramProperties[1]*maximum, histogramBins, LOGARITHMIC_BIN );
    vector<Int> histValues = prop.histogramValues();
    vector<Real> histBins = prop.histogramBins();
    
    // compute the cumulative sum of the histogram values
    ArrayProperties<Int,Int> prop2( &(histValues[0]), histValues.size() );
    vector<double> histCumulativeSum = prop2.cumulativeSum( ORDER_DESCENDING );
    cout << "\t filled volume: " << histCumulativeSum[0] / Real(size)*100. << "\%\n";
    
    
    cout << "Fitting the data with a log-normal distribution and writing the results to the ASCII file '" << outputFilename << "' ..." << flush;
    Real histogramMaxValue = Real( prop2.valueMaximum() );
    Int indexMax = prop2.indexMaximum();
    // fit around the maximum of histogram - take 4 elements before maximum to reduce the effects of the noise for smaller values
    size_t fitExtent = 5;
    size_t indexFitStart = indexMax-fitExtent, indexFitEnd = indexMax+3*fitExtent ;
    if ( indexFitStart<0 )
    {
        throwWarning( "You should increase the histogram minimum range since it is close to the maximum value of the histogram and will give wrong results for the lognormal fit." );
        indexFitStart = 0;
    }
    if ( indexFitEnd>histogramBins )
    {
        throwWarning( "You should increase the histogram maximum range since it is close to the maximum value of the histogram and will give wrong results for the lognormal fit." );
        indexFitEnd = histogramBins;
    }
    size_t const fitSize = indexFitEnd - indexFitStart;
    
    // do the fit
    Real tempY[fitSize];
    for (Int i=indexFitStart; i<indexFitEnd; ++i)
        tempY[i-indexFitStart] = Real( histValues[i] );
    logNormal fit;
    fit.dataToFit( &(histBins[indexFitStart]), tempY, fitSize );
    size_t const noParameters = fit.noFitParamaters();
    Real parameters[noParameters];
    for (size_t i=0; i<noParameters; ++i)
        parameters[i] = fit.param_n( i );
    
    
    // open the output file and write the data
    fstream outputFile;
    openOutputTextFile( outputFile, outputFilename );   //open the output file
    BOOST_ASSERT( noParameters==3 );
    
    outputFile << "# The file contains the histogram of a MMF response. The columns give the following information:\n"
            << "#\t 1st = the value at the center of the bin\n"
            << "#\t 2nd = the count number in each bin\n"
            << "#\t 3rd = the normalized histogram to the largest histogram count value\n"
            << "#\t 4th = the descending cumulative sum of the histogram\n"
            << "#\t 5th = same as 4th column, but normalized to the total number of grid cells\n"
            << "# The results were obtained using the command:  " << programOptions << "\n\n"
            << "# The histogram was fitted with a lognormal distribution - only " << fitExtent << " points to the left  and " << 2*fitExtent << " points to the right of the maximum where considered for the fit to reduce noise influence; the fit is:\n"
            << "# f1(x) = " << parameters[0] << " * exp( " << parameters[1] <<  " * (log10(x)-" << parameters[2] << ")**2 )\n"
            << "# The maximum of the fit function is at x = " << pow( Real(10.), parameters[2] ) << " .\n\n";
    
    for (size_t i=0; i<histogramBins; ++i)
        outputFile << histBins[i] << "\t" << histValues[i] << "\t" << histValues[i]/histogramMaxValue << "\t" << histCumulativeSum[i] << "\t" << histCumulativeSum[i] / Real(size) << "\n";
    outputFile.close();
    cout << "Done.\n";
}

